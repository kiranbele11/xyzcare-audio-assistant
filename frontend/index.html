<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>XYZCare Audio Assistant</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- PDF.js Library for cross-platform PDF rendering -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script>
    // Configure PDF.js worker
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
  </script>

  <style>
    :root {
      --bg: #f8f9fa; --panel: #ffffff; --muted: #6c757d; --text: #212529; --accent: #007bff; --danger: #dc3545; --ok: #28a745;
    }
    * { box-sizing: border-box; }
    body {
      margin:0; padding:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      background: var(--bg); color: var(--text);
    }
    header {
      padding: 16px 20px; border-bottom: 1px solid #dee2e6; background: #ffffffcc; position: sticky; top:0; backdrop-filter: blur(8px); z-index:10;
      display:flex; align-items:center; gap:14px;
    }
    .dot { width:10px; height:10px; border-radius:50%; background: var(--ok); box-shadow: 0 0 10px var(--ok); }
    h1 { margin:0; font-size: 18px; font-weight: 600; letter-spacing: .2px; }
    #sidebar-toggle { background: none; border: none; font-size: 24px; cursor: pointer; color: var(--text); }
    #sidebar { position: fixed; top: 64px; left: 0; height: calc(100% - 64px); width: 380px; background-color: var(--panel); border-right: 1px solid #dee2e6; padding: 16px; z-index: 100; transform: translateX(0); transition: transform 0.3s ease-in-out; box-shadow: 0 0 30px rgba(0,0,0,.1); } 
    #sidebar.closed { transform: translateX(-100%); }
    #main-content { margin-left: 380px; transition: margin-left 0.3s ease-in-out; padding: 16px; min-height: calc(100vh - 64px); } 
    #main-content.sidebar-closed { margin-left: 0; }
    @media (max-width: 980px) { 
      #sidebar { box-shadow: none; }
      #main-content { margin-left: 0; } 
      #sidebar.closed { display: none; }
    }
    .panel {
      background: var(--panel);
      border: 1px solid #dee2e6; border-radius: 12px; padding: 14px; box-shadow: 0 10px 30px rgba(0,0,0,.05);
    }
    .section-title { font-size: 13px; text-transform: uppercase; letter-spacing:.12em; color: var(--muted); margin: 0 0 8px 2px; }
    .mic-wrap { display:flex; flex-direction: column; align-items:center; gap:16px; margin: 20px 0; }
    #micBtn {
      appearance:none; 
      border: 2px solid rgba(255, 255, 255, 0.3);
      background: rgba(255, 255, 255, 0.2);
      backdrop-filter: blur(20px) saturate(180%);
      -webkit-backdrop-filter: blur(20px) saturate(180%);
      color: #007bff; 
      border-radius: 50%; 
      padding: 0;
      font-weight: 600; 
      cursor: pointer;
      box-shadow: 0 8px 32px rgba(0, 123, 255, 0.15), 
                  inset 0 1px 1px rgba(255, 255, 255, 0.5),
                  inset 0 -1px 1px rgba(0, 0, 0, 0.05);
      transition: all .3s cubic-bezier(0.4, 0, 0.2, 1);
      width: 80px;
      height: 80px;
      font-size: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: hidden;
    }
    #micBtn::before {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: 50%;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.4) 0%, rgba(255, 255, 255, 0) 100%);
      opacity: 0;
      transition: opacity .3s ease;
    }
    #micBtn:hover::before { opacity: 1; }
    #micBtn:hover { 
      transform: translateY(-2px) scale(1.05); 
      box-shadow: 0 12px 40px rgba(0, 123, 255, 0.25),
                  inset 0 1px 1px rgba(255, 255, 255, 0.6),
                  inset 0 -1px 1px rgba(0, 0, 0, 0.05);
    }
    #micBtn:active {
      transform: translateY(0) scale(0.98);
    }
    #micBtn.recording {
      border-color: rgba(255, 255, 255, 0.4);
      background: rgba(220, 53, 69, 0.3);
      color: var(--danger);
      box-shadow: 0 8px 32px rgba(220, 53, 69, 0.3),
                  inset 0 1px 1px rgba(255, 255, 255, 0.5),
                  inset 0 -1px 1px rgba(0, 0, 0, 0.05);
      animation: pulse-recording 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
    }
    @keyframes pulse-recording {
      0%, 100% { 
        box-shadow: 0 8px 32px rgba(220, 53, 69, 0.3),
                    inset 0 1px 1px rgba(255, 255, 255, 0.5),
                    inset 0 -1px 1px rgba(0, 0, 0, 0.05);
      }
      50% { 
        box-shadow: 0 8px 40px rgba(220, 53, 69, 0.5),
                    inset 0 1px 1px rgba(255, 255, 255, 0.5),
                    inset 0 -1px 1px rgba(0, 0, 0, 0.05);
      }
    }
    #micHint { color: var(--muted); font-size: 12px; text-align: center; max-width: 280px; line-height: 1.4; }
    .keyboard-hint { 
      display: inline-flex; 
      align-items: center; 
      gap: 4px; 
      padding: 2px 6px; 
      background: rgba(0, 0, 0, 0.05); 
      border-radius: 4px; 
      font-family: ui-monospace, monospace; 
      font-size: 11px;
      font-weight: 600;
      border: 1px solid rgba(0, 0, 0, 0.1);
    }
    .kv { display:grid; grid-template-columns: 110px 1fr; font-size: 13px; gap: 6px 10px; color: var(--muted); }
    .kv div.value { color: var(--text); font-weight: 600; }
    .status {
      display:flex; align-items:center; gap:10px; flex-wrap: wrap; margin-top: 10px;
    }
    .pill { font-size: 12px; padding: 6px 10px; border-radius: 999px; border:1px solid #ced4da; color: var(--muted); }
    .pill.ok { color: var(--ok); border-color: var(--ok); }
    .pill.warn { color: #ffc107; border-color: #ffc107; }
    .pill.err { color: var(--danger); border-color: var(--danger); }
    #log {
      height: 180px; overflow:auto; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px;
      background: #e9ecef; border-radius: 8px; border:1px solid #ced4da; padding: 8px; color:#495057;
      white-space: pre-wrap;
      word-break: break-all;
    }
    #pdfFrame {
      width:100%; height: calc(100vh - 120px); border:1px solid #dee2e6; border-radius: 12px; background:#f8f9fa;
    }
    /* Mobile PDF.js Viewer Styles */
    #pdfJsViewer {
      width: 100%;
      height: calc(100vh - 120px);
      border: 1px solid #dee2e6;
      border-radius: 12px;
      background: #f8f9fa;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    #pdfCanvasContainer {
      flex: 1;
      overflow: auto;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      padding: 10px;
      background: #525659;
    }
    #pdfCanvas {
      display: block;
      box-shadow: 0 4px 16px rgba(0,0,0,.3);
      background: white;
    }
    #pdfControls {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 16px;
      background: white;
      border-top: 1px solid #dee2e6;
      gap: 12px;
    }
    #pdfControls button {
      padding: 8px 16px;
      border: 1px solid #dee2e6;
      background: var(--panel);
      color: var(--text);
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      transition: all 0.2s;
    }
    #pdfControls button:hover:not(:disabled) {
      background: var(--accent);
      color: white;
      border-color: var(--accent);
    }
    #pdfControls button:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }
    #pageInfo {
      font-size: 14px;
      color: var(--muted);
      font-weight: 500;
      white-space: nowrap;
    }
    .toast { margin-top: 10px; font-size: 13px; color: var(--text); }
    a { color: var(--accent); }
  </style>
</head>
<body>
  <header>
    <button id="sidebar-toggle" aria-label="Toggle sidebar">‚ò∞</button>
    <span class="dot" aria-hidden="true"></span>
    <h1>XYZCare Audio Assistant</h1>
  </header>

  <div id="sidebar">
    <section class="panel" aria-label="Voice Controls">
      <p class="section-title">Controls</p>
      <div class="mic-wrap">
        <button id="micBtn" aria-pressed="false" aria-label="Hold to speak or click to start/stop recording">
          üé§
        </button>
        <span id="micHint">Say product name first (e.g., "LG Refrigerator Manual"), then ask questions (e.g., "Load Driver Circuit"). Press <span class="keyboard-hint">SPACE</span> to activate voice.</span>
      </div>

      <div class="status">
        <div class="kv" style="margin-top:10px; flex: 1 1 100%;">
          <div>Manual</div><div class="value" id="manualVal">‚Äî</div>
          <div>Transcript</div><div class="value" id="transcriptVal">‚Äî</div>
        </div>
      </div>

      <div style="margin-top:12px;">
        <div class="section-title">Log</div>
        <pre id="log" aria-live="polite"></pre>
        <div class="toast" id="toast"></div>
      </div>
    </section>
  </div>

  <div id="main-content">
    <section class="panel" aria-label="Manual Viewer">
      <p class="section-title">Manual</p>

      <!-- Desktop: Native iframe PDF viewer -->
      <iframe id="pdfFrame" title="Manual PDF Viewer"></iframe>

      <!-- Mobile: PDF.js canvas viewer -->
      <div id="pdfJsViewer" style="display:none;">
        <div id="pdfCanvasContainer">
          <canvas id="pdfCanvas"></canvas>
        </div>
        <div id="pdfControls">
          <button id="prevPage" aria-label="Previous page">‚Üê Previous</button>
          <span id="pageInfo">Page 1 of 1</span>
          <button id="nextPage" aria-label="Next page">Next ‚Üí</button>
        </div>
      </div>
    </section>
  </div>

  <script>
    (function () {
      const micBtn = document.getElementById('micBtn');
      const manualVal = document.getElementById('manualVal');
      const transcriptVal = document.getElementById('transcriptVal');
      const logEl = document.getElementById('log');
      const toastEl = document.getElementById('toast');
      const pdfFrame = document.getElementById('pdfFrame');
      const sidebar = document.getElementById('sidebar');
      const mainContent = document.getElementById('main-content');
      const sidebarToggle = document.getElementById('sidebar-toggle');

      sidebarToggle.addEventListener('click', () => {
        sidebar.classList.toggle('closed');
        mainContent.classList.toggle('sidebar-closed');
      });

      let mediaRecorder = null;
      let chunks = [];
      let isRecording = false;
      let state = {
        manualId: null,
        manualTitle: null,
        lastLatencyMs: null,
        pdfUrl: null,  // Store current PDF URL
      };

      // Detect mobile browsers
      const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);

      // PDF.js viewer elements and state
      const pdfJsViewer = document.getElementById('pdfJsViewer');
      const pdfCanvas = document.getElementById('pdfCanvas');
      const pdfCanvasContainer = document.getElementById('pdfCanvasContainer');
      const prevPageBtn = document.getElementById('prevPage');
      const nextPageBtn = document.getElementById('nextPage');
      const pageInfoSpan = document.getElementById('pageInfo');

      let pdfDoc = null;
      let currentPage = 1;

      // Show appropriate viewer based on device
      if (isMobile) {
        pdfFrame.style.display = 'none';
        pdfJsViewer.style.display = 'flex';
      } else {
        pdfFrame.style.display = 'block';
        pdfJsViewer.style.display = 'none';
      }

      function log(msg) {
        const ts = new Date().toISOString().split('T')[1].replace('Z','');
        logEl.textContent += '[' + ts + '] ' + msg + '\n';
        logEl.scrollTop = logEl.scrollHeight;
      }

      function toast(msg, persist = false) {
        toastEl.textContent = msg;
        if (!persist) {
          setTimeout(() => { toastEl.textContent = ''; }, 4000);
        }
      }
      
      function clearToast() {
        toastEl.textContent = '';
      }

      // PDF.js rendering functions for mobile
      async function renderPDFPage(pageNum) {
        if (!pdfDoc) return;

        try {
          const page = await pdfDoc.getPage(pageNum);
          const context = pdfCanvas.getContext('2d');

          // Calculate responsive scale based on container width
          const containerWidth = pdfCanvasContainer.clientWidth - 20; // Account for padding
          const viewport = page.getViewport({ scale: 1 });
          const scale = Math.min(containerWidth / viewport.width, 2.5); // Max scale 2.5x
          const scaledViewport = page.getViewport({ scale: scale });

          pdfCanvas.height = scaledViewport.height;
          pdfCanvas.width = scaledViewport.width;

          // Render PDF page
          await page.render({
            canvasContext: context,
            viewport: scaledViewport
          }).promise;

          // Update UI
          currentPage = pageNum;
          pageInfoSpan.textContent = `Page ${pageNum} of ${pdfDoc.numPages}`;
          prevPageBtn.disabled = (pageNum <= 1);
          nextPageBtn.disabled = (pageNum >= pdfDoc.numPages);

          log(`Rendered page ${pageNum} of ${pdfDoc.numPages}`);
        } catch (err) {
          log(`Error rendering page ${pageNum}: ${err.message}`);
        }
      }

      async function loadPDFWithPDFjs(url, pageNum = 1) {
        try {
          log('Loading PDF with PDF.js...');
          const loadingTask = pdfjsLib.getDocument(url);
          pdfDoc = await loadingTask.promise;
          log(`PDF loaded: ${pdfDoc.numPages} pages`);
          await renderPDFPage(pageNum);
        } catch (err) {
          log(`PDF.js load error: ${err.message}`);
          toast('Failed to load PDF.');
        }
      }

      // Navigation controls for mobile PDF viewer
      if (isMobile) {
        prevPageBtn.addEventListener('click', async () => {
          if (currentPage > 1) {
            await renderPDFPage(currentPage - 1);
          }
        });

        nextPageBtn.addEventListener('click', async () => {
          if (currentPage < pdfDoc.numPages) {
            await renderPDFPage(currentPage + 1);
          }
        });
      }

      // Unified PDF loading function for both desktop and mobile
      async function loadPDF(url, pageNum = 1) {
        state.pdfUrl = url;

        if (isMobile) {
          // Use PDF.js for mobile
          await loadPDFWithPDFjs(url, pageNum);
        } else {
          // Use native iframe for desktop
          const targetUrl = url + '#page=' + pageNum;

          // Extract base URLs without fragments or query params for comparison
          const getCurrentBase = () => {
            if (!pdfFrame.src) return '';
            try {
              const srcUrl = new URL(pdfFrame.src, window.location.origin);
              return srcUrl.origin + srcUrl.pathname;
            } catch {
              return pdfFrame.src.split('#')[0].split('?')[0];
            }
          };

          const getTargetBase = () => {
            try {
              const targetFullUrl = new URL(targetUrl, window.location.origin);
              return targetFullUrl.origin + targetFullUrl.pathname;
            } catch {
              return targetUrl.split('#')[0].split('?')[0];
            }
          };

          const currentBase = getCurrentBase();
          const targetBase = getTargetBase();

          if (currentBase && currentBase === targetBase) {
            // Same PDF, just changing page
            // Force reload by briefly setting to empty, then to new URL
            const temp = pdfFrame.src;
            pdfFrame.src = '';
            setTimeout(() => {
              pdfFrame.src = targetUrl;
              log('Reloaded iframe with new page fragment: ' + targetUrl);
            }, 50);
          } else {
            // Different PDF - normal load
            pdfFrame.src = targetUrl;
            log('Loaded new PDF in iframe: ' + targetUrl);
          }
        }
      }

      function chooseMime() {
        const preferred = ['audio/webm;codecs=opus', 'audio/webm'];
        for (const m of preferred) {
          if (MediaRecorder.isTypeSupported(m)) return m;
        }
        return ''; // Let browser decide
      }

      async function startRecording() {
        if (isRecording) return;
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          toast('Microphone not available.');
          log('MediaDevices.getUserMedia not supported');
          return;
        }
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          const mimeType = chooseMime();
          chunks = [];
          mediaRecorder = new MediaRecorder(stream, mimeType ? { mimeType } : {});
          mediaRecorder.ondataavailable = (e) => { if (e.data && e.data.size > 0) chunks.push(e.data); };
          mediaRecorder.onstop = onStopRecording;
          mediaRecorder.start();
          isRecording = true;
          micBtn.classList.add('recording');
          micBtn.setAttribute('aria-pressed', 'true');
          log('Recording started...');
          // Auto-stop after 7 seconds for snappy demo
          setTimeout(() => { if (isRecording) stopRecording(); }, 7000);
        } catch (err) {
          console.error(err);
          toast('Failed to access microphone.');
          log('Error starting recording: ' + (err && err.message ? err.message : String(err)));
        }
      }

      function stopRecording() {
        if (!isRecording) return;
        isRecording = false;
        micBtn.classList.remove('recording');
        micBtn.setAttribute('aria-pressed', 'false');
        try {
          mediaRecorder.stop();
          log('Recording stopped. Processing...');
        } catch (e) {
          log('Error stopping recorder: ' + e);
        }
      }

      async function onStopRecording() {
        try {
          const blob = new Blob(chunks, { type: chunks[0]?.type || 'audio/webm' });
          await handleUtterance(blob);
        } catch (e) {
          log('onStop error: ' + e);
        } finally {
          // Cleanup tracks
          try {
            mediaRecorder.stream.getTracks().forEach(t => t.stop());
          } catch {}
        }
      }

      async function handleUtterance(audioBlob) {
        clearToast(); // Clear any persistent toast when starting new utterance
        const t0 = performance.now();
        transcriptVal.textContent = '‚Ä¶';
        const form = new FormData();
        const ext = (audioBlob.type.includes('wav') ? 'wav' : 'webm');
        form.append('file', audioBlob, 'audio.' + ext);

        let transcript = null;
        try {
          const resp = await fetch('/api/stt', { method: 'POST', body: form });
          const t1 = performance.now();
          if (!resp.ok) {
            let errorDetail = resp.statusText;
            try {
              const errorData = await resp.json();
              errorDetail = errorData.detail || resp.statusText;
            } catch (e) {
              // If can't parse JSON, use statusText
            }
            const msg = 'STT error: ' + resp.status + ' - ' + errorDetail;
            toast(msg);
            log(msg);
            transcriptVal.textContent = '‚Äî';
            return;
          }
          const data = await resp.json();
          transcript = (data && data.transcript) ? data.transcript.trim() : '';
          transcriptVal.textContent = transcript || '‚Äî';

          // Log transcript and timing
          const latency = t1 - t0;
          log('Transcript: ' + transcript);
          log('Latency: ' + Math.round(latency) + 'ms (Total), ' + (data.api_duration_ms || 'n/a') + 'ms (API)');

          if (!transcript) {
            toast('No speech detected.');
            return;
          }

          // Process transcript for manual resolution and search
          if (!state.manualId) {
            await resolveManual(transcript);
          } else {
            // Check if user wants to open/switch manuals
            // Only trigger on explicit "manual" keyword or action verbs "open"/"show"
            const lowerTranscript = transcript.toLowerCase();
            const isManualTrigger = lowerTranscript.includes('manual') ||
                                   lowerTranscript.startsWith('open ') ||
                                   lowerTranscript.startsWith('show ');

            if (isManualTrigger) {
              // User wants to switch manuals
              await resolveManual(transcript);
            } else {
              // Search within current manual
              await askWithinManual(transcript);
            }
          }

        } catch (e) {
          const t1 = performance.now();
          toast('Network error during STT.');
          log('STT exception: ' + e);
        }
      }

      async function resolveManual(query) {
        const url = '/api/manual/resolve?q=' + encodeURIComponent(query);
        log('Resolving manual: ' + query);
        const t0 = performance.now();
        try {
          const resp = await fetch(url);
          const t1 = performance.now();
          if (!resp.ok) {
            toast('Manual resolution failed (' + resp.status + ').');
            log('Resolve error: ' + resp.status + ' ' + resp.statusText);
            return;
          }
          const data = await resp.json();
          // Expected: { manual_id, title, filename }
          if (!data.manual_id) {
            toast('Ambiguous. Please be more specific.');
            log('Resolve response ambiguous: ' + JSON.stringify(data));
            return;
          }
          // Only switch manual if it's different from current one
          if (state.manualId !== data.manual_id) {
            state.manualId = data.manual_id;
            state.manualTitle = data.title || data.filename || ('Manual ' + data.manual_id);
            manualVal.textContent = state.manualTitle;

            // Fetch PDF URL from backend (returns JSON with presigned URL)
            const pdfApiUrl = '/api/manual/' + encodeURIComponent(state.manualId) + '/pdf';
            const pdfResp = await fetch(pdfApiUrl);
            if (pdfResp.ok) {
              const pdfData = await pdfResp.json();
              await loadPDF(pdfData.url, 1);
              toast('Manual loaded: ' + state.manualTitle);
              log('Loaded PDF from: ' + pdfApiUrl);
            } else {
              toast('Failed to load PDF.');
              log('PDF fetch error: ' + pdfResp.status);
            }
          } else {
            log('Manual already loaded: ' + state.manualTitle + '. Treating as search.');
            await askWithinManual(query);
          }
        } catch (e) {
          toast('Error resolving manual.');
          log('Resolve exception: ' + e);
        }
      }

      async function askWithinManual(question) {
        if (!state.manualId) return;
        const url = '/api/manual/' + encodeURIComponent(state.manualId) + '/search';
        log('Searching within manual: ' + question);
        const t0 = performance.now();
        try {
          const resp = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ question })
          });
          const t1 = performance.now();
          if (!resp.ok) {
            toast('Search failed (' + resp.status + ').');
            log('Search error: ' + resp.status + ' ' + resp.statusText);
            return;
          }
          const data = await resp.json();
          // Expected: { page, score, snippet }
          if (!data.page) {
            toast('No relevant section found.');
            log('Search response: ' + JSON.stringify(data));
            return;
          }
          jumpToPage(data.page);
          const summary = data.snippet ? (' ‚Äî ' + data.snippet.slice(0, 140) + (data.snippet.length > 140 ? '‚Ä¶' : '')) : '';
          toast('üìÑ Page ' + data.page + summary, true); // Persistent toast
          log('Rerank score: ' + (data.score !== undefined && data.score !== null ? data.score.toFixed(3) : 'n/a'));
        } catch (e) {
          toast('Error searching manual.');
          log('Search exception: ' + e);
        }
      }

      async function jumpToPage(pageNum) {
        if (!state.pdfUrl) {
          log('Cannot jump to page: PDF not loaded');
          return;
        }

        if (isMobile && pdfDoc) {
          // Mobile: Already have PDF loaded, just render the new page
          await renderPDFPage(pageNum);
          log('Viewer navigated to page ' + pageNum);
        } else {
          // Desktop: Update iframe src with new page fragment
          await loadPDF(state.pdfUrl, pageNum);
          log('Viewer navigated to page ' + pageNum);
        }
      }

      // Wire UI
      micBtn.addEventListener('click', () => {
        if (isRecording) stopRecording(); else startRecording();
      });

      // Keyboard shortcut: Spacebar to toggle recording
      document.addEventListener('keydown', (e) => {
        // Only trigger if not focused on an input element
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
        
        if (e.code === 'Space' || e.key === ' ') {
          e.preventDefault(); // Prevent page scroll
          if (isRecording) {
            stopRecording();
          } else {
            startRecording();
          }
        }
      });

      log('UI loaded. Click the mic or press SPACE to speak.');
    })();
  </script>
</body>
</html>
